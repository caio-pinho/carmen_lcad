Mapper constrﾃｳi o mapa do ambiente ao redor

Localizer estima o estado em relaﾃｧﾃ｣o ﾃ origem do mapa

Path planning constrﾃｳi o caminho da pose inicial para a pose final, obedecendo restriﾃｧﾃｵes de limites da via e parﾃ｢metros de operaﾃｧﾃ｣o do carro como velocidade mﾃ｡xima.

High Level Decision Maker estabelece uma lane (pista, faixa) e um goal state nela (na lane), considerando regras de trﾃ｢nsito e o comportamento do trﾃ｢nsito.

Motion Planner ﾃｩ responsﾃ｡vel por planejar uma trajetﾃｳria do estado atual para o goal state, enquanto segue a lane e evita eventuais obstﾃ｡culos. A trajetﾃｳria ﾃｩ composta por velocidade e comandos de ﾃ｢ngulo do volante associados com tempos de execuﾃｧﾃ｣o.

MPMP recebe um mapa, uma lane e um goal state a uma taxa de 20Hz e computa uma trajetﾃｳria do estado atual para uma pose e velocidade da lane o mais prﾃｳximo possﾃｭvel do goal state, enquanto seguindo a lane e evitando obstﾃ｡culos, considerando cinemﾃ｡tica e restriﾃｧﾃｵes dinﾃ｢micas do veﾃｭculo, em contraste com o problema de path planning, que objetiva planejar um path (lista de pontos de passagem) considerando apenas restriﾃｧﾃｵes cinemﾃ｡ticas.

Motion planning methods employ mainly state lattice, rapidly-exploring random tree (RRT), interpolation, optimization, and model predictive techniques [BAU15].

In this work, the control 搨 is defined by the command of velocity and steering angle during a specific time variation, the time and steering angle control are parameterized as a spline. As shown below. 搨 = [搗｣,撩,搗｡]  撩 = 搗搗晰搗咀搗役搗幤搗(竏搗｡)

Alberto:
O motion planner recebe o path (o caminho), o goal (no caminho) e a velocidade do goal e o estado atual do veﾃｭculo. Ele gera uma trajetﾃｳria (um sequﾃｪncia de estados atﾃｩ o estado final), onde o estado final ﾃｩ o estado que foi especificado (goal e a velocidade do goal).


Handlers:
(Registrado/subscrito)
localize_ackerman_globalpos_message_handler: entra depois de alguns loops (talvez nﾃ｣o, desde sempre).
Seta a global state::localizer_pose com globalpos.x, globalpos.y globalpos.theta, e beta (oriundas da msg).
Em seguida roda o build_and_follow_path(com o timestamp da msg)

simulator_ackerman_truepos_message_handler: nﾃ｣o entrou nesse handler;(nﾃ｣o subscreveu pois nﾃ｣o ﾃｩ use_truepos);

(Registrado/subscrito)
path_goals_and_annotations_message_handler: recebeu antes de iniciar a geraﾃｧﾃ｣o do path (provavelmente quando setei o goal);
Seta goal_pose.x, goal_pose.y, goal_pose.theta (normalize antes de setar) e goal_pose.beta (todos oriundos da msg);
Seta tambﾃｩm o desired_v, comparando o goal_list.v com o param_max_vel e usando o menor entre eles. Corrige o robot_config.max_v.
Seta o set_goal_pose com o goal_pose (parﾃ｢metros recebidos da msg e setados anteriormente)

(Registrado/subscrito)
base_ackerman_odometry_message_handler: recebendo sempre, setando o globalstate::last_odometry.v e o last_odometry.phi com a msg recebida.
Setou sempre o eliminate_path_follower = 1;

(Registrado/subscrito)
behavior_selector_state_message_handler: aparentemente recebendo sempre,


Publishers:
publish_robot_ackerman_motion_commands_eliminating_path_follower: transforma o path em smooth_short_path e depois publica em publish_model_predictive_planner_motion_commands(path, timestamp)

desired_v = goal_list[0].v (lﾃ｡ na frente ficou = 0, enquanto last_odometry estava em 8.187 e robot_config.max_v_depois e target_v estava em 0.682003)
Verificar qual o ponto ﾃｩ o goal_list[0] (de onde vem o goal_list[0].v), se o goal final, ou se o primeiro goal do path (ﾃｩ o mesmo do goal_pose)

localizer_pose 7757512 coloquei aqui
goal_pose (primeiro) 7757522 / 7757523
goal_pose (ultimo) 7757583 final_goal coloquei 7757583
Quando gera o goal ( quando aperta o compute route), o goal ﾃｩ o primeiro goal, e a velocidade jﾃ｡ ﾃｩ a final 8.55
Goal: 7757522.59, -363657.77, -0.209 (-11.97 deg) (30.78km/h, 8.55 m/s)
Num_commands variando de 27 a 142. Comeﾃｧou em 139, quando andou caiu, chegou a 88, subiu atﾃｩ 142 e caiu atﾃｩ 27.

msg.path[99].p2.beta gerando um nﾃｺmero gigantesco
.p2.x ﾃｩ o prﾃｳximo .p1.x (y tb)
Primeiro gera os commands, e depois constrﾃｳi-se os msg.path. 
v=8.546, t = 0.06 (penﾃｺltimo command, o prﾃｳximo ﾃｩ 8.550, t=0.000 (112, na verdade 113o comando (comeﾃｧa em 0))).

Gera na ordem:
desired_v, target_v, localizer_pose (x, y, theta), last_odometry (v, phi), goal_pose (x,y, theta), msg_path[0] (p1.x, p2.x, p1.y, p2.y, p1.v, p2.v, v, p1.phi, p2.phi, phi, p1.beta, p2.beta, p1.theta, p2.theta), goal_pose (x, y, theta), msg_path[1]. goal_pose, msg_path[2], goal_pose窶ｦmsg_path[134], repete:
desired_v, GOAL_LIST[0].v, target_v, localizer_pose, last_odometry, goal_pose, msg_path

Reduzindo o nﾃｺmero de comandos para 10, parou de gerar os comandos apﾃｳs possﾃｭvel colisﾃ｣o
Com 10 comandos, o obstacle avoider plan as vezes gera uma rota circular (arquivo salvo na pasta carmen_lcad)
Zerando o x, y, theta e beta (sobrando apenas v, phi, t) dos comandos gerados, ainda executou normalmente (sem limitar a quantidade de comandos rodou perfeitamente atﾃｩ o final).
Com os valores acima zerados e alterando o t para 1.0, nﾃ｣o saiu do lugar (gerou uma linha curva do obstacle avoider plan).
Com os valores acima zerados e alterando o t para 0.02, executou perfeitamente (possibilidade de predizer apenas v e phi, mantendo t constante)
Com o tempo em 0.02 e setando o v para 0.016, nﾃ｣o saiu do lugar.
Com o tempo em 0.02 e setando o v para 0.24, andou lentamente (1.0 km/h, 0.26 m/s).
Com o tempo em 0.02 e setando o v para 0.7, andou menos lentamente (2.8 km/h, 0.77 m/s).
Com o tempo em 0.02 e setando o v para 3.0, andou rapidamente (10.8 km/h, 2.99 m/s), e executou o previsto (mesmo na curva), porﾃｩm estacionou fora da pose (em um dos testes passou o destino e continuou seguindo na via (OFFROAD_ERROR)).
Com o phi setado em 0, o carro andou atﾃｩ encontrar um objeto (foi andando em linha reta atﾃｩ sair ligeiramente da pista, onde encontrou um objeto acabou parando).


Com 25 comandos rodou relativamente bem (nﾃ｣o foi atﾃｩ o final do trajeto).
Com 50 comandos foi atﾃｩ mais prﾃｳximo do final do trajeto.
Com 100 comandos o NMP morreu (faltaram comandos para preencher). Setado no seguinte caminho:
for (std::vector<carmen_robot_and_trailer_path_point_t>::iterator it = path.begin();   it != path.end(); ++it)//i < 100; ++it)//it != path.end(); ++it)




Low Level State: Free_Running em ambos os casos (tentar achar o Route Planner State: EXECUTING_OFFROAD_PLAN
Sem o obstacle_avoider carro nﾃ｣o andou, sem o behavior tambﾃｩm nﾃ｣o

11518 comeﾃｧou a andar, 11581 zerou a velocidade. Gerou 2000 num_commands com 152 comandos (152 linhas de commands timestamp no mesmo milissegundo, depois 304 no mesmo milissegundo, depois 456 no mesmo milissegundo, depois 304, depois 304, depois 304, depois 456, depois 304..) (atﾃｩ a linha 2.241.221), e seguiu gerando num_commands com variaﾃｧﾃｵes (135, 136, 窶ｦ). Os num_commands com variaﾃｧﾃｵes (que provavelmente foram os movimentos reais), geraram com diferenﾃｧa de timestamp de aprox. 0.050 entre um e outro, enquanto os comandos gerados por mim geraram em sequﾃｪncia de 0.001 de diferenﾃｧa.

15396 comeﾃｧou a andar15433 morreu. 134 comandos com o mesmo timestamp, pulou 0.052 para o prﾃｳximo commands timestamp.
Segundo commands timestamp gerou 135 linhas de comando.


Viewer 3D:
Linha verde grossa: Motion Plan
Show Path Plans: mostra as linhas das vias e possﾃｭveis caminhos

Sem o NMP o Compute Route ainda funciona, gera o caminho, os paths e plota no mapa (nﾃ｣o ﾃｩ necessﾃ｡rio o NMP para gerar o caminho)
Mﾃｭnimo funcionando para gerar o caminho: route_planner e behavior_selector (nﾃ｣o precisa do offroad_planner, nﾃ｣o precisa do NMP e nﾃ｣o precisa do obstacle_avoider).
Sﾃｳ com o route_planner ele gera uma linha azul em cima da linha da rua mas nﾃ｣o gera as poses do carro ao longo dessa linha azul. Quando liga o behavior selector as poses e os fachos de linhas verdes ao longo do caminho aparecem

O behavior_selector (BS)  (i) computa um conjunto de paths usando Frenet Frames; (ii) escolhe um goal que possa ser alcanﾃｧado sem colisﾃ｣o em cada path; (iii) determina a velocidade em cada um destes goals; (iv) e escolhe o melhor conjunto path/goal/velocidade do goal.

Rodando o GO sem o Compute Route, o carro seguiu os comandos enviados no Go personalizado com single motion command editado (sem rota planejada, seguiu reto, mas andou!)
Gerando uma ﾃｺnica sequﾃｪncia de 136 comandos, com v=3 e t=10, quase andou (v foi a 0.3 e voltou pra 0, mas nﾃ｣o saiu do lugar).
Invertendo a lﾃｳgica, gerando 300 sequﾃｪncias de 1 comando, com v=3 e t=10, andou por vﾃ｡rios segundos (aproximadamente 10 segundos, 0.049 km) em linha reta!
Simulando o mesmo teste anterior, porﾃｩm com 1500 sequﾃｪncias do mesmo 1 comando anterior, percorreu 0.091 km em linha reta (nﾃ｣o respeitando possﾃｭveis objetos no caminho, seguiu sem parar), por aproximadamente 46 segundos. A velocidade nﾃ｣o variou muito, nﾃ｣o passando de cerca de 6 km/h (planejado era 3 m/s, ou seja, 10,8 km/h).

Clicando no Compute Route, ele chama uma funﾃｧﾃ｣o carmen_route_planner_set_destination(char *destination, carmen_point_t destination_point);

Build_and_follow_path: nﾃ｣o ﾃｩ necessﾃ｡rio rodar para gerar as poses (path e goals), comentei e mesmo assim gerou a rota.
New_commands com following_path = true, nﾃ｣o move.

Sequﾃｪncia lﾃｳgica:
Pressionando o Go (com o compute route previamente pressionado), o GlobalState::following_path = true;


Pensando de maneira lﾃｳgica:

Preciso do goal (primeiro goal do path) para calcular os comandos;
Onde sﾃ｣o gerados os goals do path?



Publishers:
	publish_model_predictive_planner_motion_commands(vector<carmen_robot_and_trailer_path_point_t> path, double timestamp)
		carmen_robot_ackerman_publish_motion_command(commands, num_commands, timestamp);
		
	publish_robot_ackerman_motion_commands_eliminating_path_follower(vector<carmen_robot_and_trailer_path_point_t> &original_path, double timestamp)
		publish_model_predictive_planner_motion_commands(path, timestamp); SE COMENTAR AQUI Nﾃグ RODA, O CAMINHO Nﾃグ FICA VERMELHO (FICA VERDE)
		
	publish_model_predictive_planner_rrt_path_message(list<RRT_Path_Edge> path, double timestamp)
		ENTENDER O QUE ACONTECE AQUI
		pode ser que o problema seja a falta do Publisher_Util::publish_rrt_path_message(&msg): acho que nﾃ｣o, o normal rodou sem isso aqui
	
	publish_path_follower_motion_commands(carmen_robot_and_trailer_motion_command_t *commands, int num_commands, double timestamp)
		ENTROU NESSE DEPOIS QUE PAROU DE FOLLOWING PATH
		
	publish_path_follower_single_motion_command(double v, double phi, double timestamp)
		publish_path_follower_motion_commands(commands, 2, timestamp);
		
	publish_model_predictive_planner_single_motion_command(double v, double phi, double timestamp)
		publish_model_predictive_planner_motion_commands(path, timestamp);
		publish_path_follower_single_motion_command(0.0, phi, timestamp);
		
	publish_navigator_ackerman_plan_message(carmen_robot_and_trailer_traj_point_t *path, int path_size)
		Publisher_Util::publish_navigator_ackerman_plan_message(msg); testei sem esse, o normal rodou sem isso aqui
		
	publish_navigator_ackerman_status_message()
		err = IPC_publishData(CARMEN_NAVIGATOR_ACKERMAN_STATUS_NAME, &msg); Nﾃグ RODOU SEM ISSO AQUI (mas o caminho ficou verde, vermelho, mas nﾃ｣o saiu do lugar)! 
											Mas quando coloquei no new_commands tambﾃｩm nﾃ｣o rodou (o caminho nﾃ｣o ficou vermelho).
											
		
	publish_plan_tree_for_navigator_gui(Tree tree)
		Publisher_Util::publish_plan_tree_message(tree); testei sem esse, o normal rodou sem isso aqui


quando rodo pelo meu command, a linha verde desaparece quando clico no go (mesmo com following_path e sem o following_path)
linha verde: Motion plan. no movimento normal, quando Go a linha verde ﾃｩ sobreposta pela linha vinho, que ﾃｩ a do obstacle avoider (que fica sobre a linha verde) e vai se deslocando em direﾃｧﾃ｣o ao primeiro goal do path (que vai se movendo pra frente)
sﾃｳ gerou a linha verde e a linha vinho com o NMP ligado no modo normal (depende do NMP para gerar a linha mesmo)
Compilar o predict_commands: gcc predict_commands.c -lm -o predict_commands
	
Funﾃｧﾃｵes:



Handlers:
	localize_ackerman_globalpos_message_handler(carmen_localize_ackerman_globalpos_message *msg)
		*GlobalState::localizer_pose = {msg->globalpos.x, msg->globalpos.y, msg->globalpos.theta, msg->beta};
		build_and_follow_path(msg->timestamp);
		
	simulator_ackerman_truepos_message_handler(carmen_simulator_ackerman_truepos_message *msg)
		Nﾃグ PASSOU POR AQUI
		
	path_goals_and_annotations_message_handler(carmen_behavior_selector_path_goals_and_annotations_message *msg)
		GlobalState::set_goal_pose(goal_pose);
		
	base_ackerman_odometry_message_handler(carmen_base_ackerman_odometry_message *msg)
	
	behavior_selector_state_message_handler(carmen_behavior_selector_state_message *msg)
	
	carmen_obstacle_distance_mapper_compact_map_message_handler(carmen_obstacle_distance_mapper_compact_map_message *message)
